---
title: 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）
tags:
  - 计算机-编程设计
---

![](https://cdn.weread.qq.com/weread/cover/26/YueWen_603120/s_YueWen_603120.jpg)


## 第一部分 走近Java




!!! note "笔记"

	 认识这些技术运作的本质，是自己思考“程序这样写好不好”的基础和前提。当我们在使用一种技术时，如果不再依赖书本和他人就能得到这些问题的答案，那才算上升到了“不惑”的境界。
 


!!! note "笔记"

	 譬如 


!!! note "笔记"

	 OpenJDK 


!!! note "笔记"

	 Apache Harmony 


## 第二部分 自动内存管理机制




!!! note "笔记"

	 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。 


!!! note "笔记"

	 每个方法在执行的同时都会 


!!! note "笔记"

	 创建一个栈帧（Stack Frame)￼用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程 


!!! note "笔记"

	 经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。 


!!! note "笔记"

	 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 


!!! note "笔记"

	 从内存回收的角度来看，由于现在收集器基本都采用分代收集算法 


!!! note "笔记"

	 所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。 


!!! note "笔记"

	 内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。 


!!! note "笔记"

	 在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。 


!!! note "笔记"

	 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 


!!! note "笔记"

	 永久代”（Permanent Generation） 


!!! note "笔记"

	 运行时常量池（Runtime Constant Pool） 


!!! note "笔记"

	 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，本书第7章将探讨这部分内容的细节。
 


!!! note "笔记"

	 对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
 


!!! note "笔记"

	 对象头包括两部分信息 


!!! note "笔记"

	 第一部分用于存储对象自身的运行时数据， 


!!! note "笔记"

	 官方称它为“Mark Word” 


!!! note "笔记"

	 ，在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，而在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容见表2-1。 


!!! note "笔记"

	 对象头的另外一部分是类型指针 


!!! note "笔记"

	 字符串常量池 


### 第3章 垃圾收集器与内存分配策略




!!! note "笔记"

	 那为什么我们还要去了解GC和内存分配呢？答案很简单：当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。
 


!!! note "笔记"

	 标记-清除”（Mark-Sweep）算法， 


!!! note "笔记"

	 当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。 


!!! note "笔记"

	 分配担保 


!!! note "笔记"

	 OopMap 


!!! note "笔记"

	 -XX:+PrintGCDetails 


!!! note "笔记"

	 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 


!!! note "笔记"

	 下面解释一下“冒险”是冒了什么风险，前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。 


### 第4章 虚拟机性能监控与故障处理工具




!!! note "笔记"

	 JDK开发团队选择采用Java代码来实现这些监控工具是有特别用意的：当应用程序部署到生产环境后，无论是直接接触物理服务器还是远程Telnet到服务器上都可能会受到限制。借助tools.jar类库里面的接口，我们可以直接在应用程序中实现功能强大的监控分析功能[插图]。 


!!! note "笔记"

	 [protocol:][//]lvmid[@hostname[:port]/servername]
参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：
 jstat -gc 2764 250 20
选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译状况，具体选项及作用请参考表4-3中的描述。 


## 第三部分 虚拟机执行子系统




!!! note "笔记"

	 将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。
 


!!! note "笔记"

	 Java虚拟机采用面向操作数栈而不是寄存器的架构 


### 第7章 虚拟机类加载机制




!!! note "笔记"

	 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
 


!!! note "笔记"

	 加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。 


!!! note "笔记"

	 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 


### 第8章 虚拟机字节码执行引擎




!!! note "笔记"

	 泽 


!!! note "笔记"

	 局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息 


!!! note "笔记"

	 局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。 


!!! note "笔记"

	 变量槽（Variable Slot，下称Slot 


!!! note "笔记"

	 一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、byte、char、short、int、float、reference[插图]和returnAddress 8种类型 


!!! note "笔记"

	 那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数 


!!! note "笔记"

	 当一个方法开始执行后，只有两种方式可以退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（NormalMethod Invocation Completion）。 


!!! note "笔记"

	 另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method InvocationCompletion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。 


!!! note "笔记"

	 方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。 


## 第五部分 高效并发




!!! note "笔记"

	 处理器至少要与内存交互 


!!! note "笔记"

	 如读取运算数据、存储运算结果等 


!!! note "笔记"

	 由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。 


!!! note "笔记"

	 可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象 


!!! note "笔记"

	 乱序执行（Out-Of-Order Execution）优化 


!!! note "笔记"

	 指令重排序（Instruction Reorder）优化 


!!! note "笔记"

	 来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。 


!!! note "笔记"

	 Java内存模型规定了所有的变量都存储在主内存（Main Memory）中 


!!! note "笔记"

	 每条线程还有自己的工作内存 


!!! note "笔记"

	 第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。 


!!! note "笔记"

	 XX:+PrintAssembly参数 


!!! note "笔记"

	 [插图]运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。[插图]变量不需要与其他的状态变量共同参与不变约束。 


!!! note "笔记"

	 volatile变量的第二个语义是禁止指令重排序优化 


!!! note "笔记"

	 Within-Thread As-If-Serial Semantics 


!!! note "笔记"

	 非原子性协定（Nonatomic Treatment of double and longVariables）。 


!!! note "笔记"

	 目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待 


!!! note "笔记"

	 因此我们在编写代码时一般不需要把用到的long和double变量专门声明为volatile。 


!!! note "笔记"

	 如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等 


### 第13章 线程安全与锁优化




!!! note "笔记"

	 应性自旋（AdaptiveSpinning） 


!!! note "笔记"

	 锁消除（Lock Elimination 


!!! note "笔记"

	 对象头（Object Header）分为两部分信息 


!!! note "笔记"

	 非固定的数据结构 

